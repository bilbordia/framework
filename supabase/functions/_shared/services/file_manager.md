# FileManagerService

## Overview

The `FileManagerService` is a critical component within the `supabase/functions/_shared/` directory. Its primary purpose is to provide a centralized and standardized way to manage all file operations related to the Dialectic feature. This service ensures that:

1.  **Consistent File Pathing**: All files are stored in Supabase Storage using a predefined, logical directory structure. This structure is essential for organization, future export features, and potentially for direct user interaction with the file system (e.g., via GitHub integration). The paths are generated by the `constructStoragePath` utility, driven by the `PathContext`.
2.  **Database Synchronization**: Every file uploaded to storage has a corresponding metadata record created in the appropriate database table (`dialectic_project_resources` or `dialectic_contributions`). This link is vital for file discoverability, managing permissions (via RLS on the tables), and associating files with their respective projects, sessions, stages, and AI contributions.
3.  **Simplified File Operations**: It abstracts the complexities of direct Supabase Storage calls and database inserts/updates related to file metadata, providing a simpler API for other backend services.
4.  **Atomic Operations (Best Effort)**: When registering a file, it first uploads to storage and then creates the database record. If the database insert fails, it attempts to clean up the orphaned file from storage.

Using `FileManagerService` for all file-related tasks is **mandatory** to maintain data integrity and consistency across the application.

## Core Concepts

### `FileType`

A string literal union that defines the type of file being handled. This type dictates the storage path construction and the target database table for metadata. Key types include:

*   `'initial_user_prompt'`: The initial file provided by the user when creating a project.
*   `'system_settings'`: JSON file storing session settings (models, prompt templates used).
*   `'seed_prompt'`: The fully constructed prompt sent to an AI model for a specific stage.
*   `'model_contribution_main'`: The primary output file from an AI model (e.g., a Markdown document).
*   `'model_contribution_raw_json'`: The raw JSON response from the AI model provider.
*   `'user_feedback'`: User-provided feedback on a particular stage or contribution.
*   `'contribution_document'`: Additional documents generated by or associated with a model's contribution (e.g., a PRD generated from a synthesis).
*   _(Other types like `'project_readme'`, `'general_resource'` may also be managed)_

### `PathContext`

An object providing the necessary context to construct a unique and correct storage path for a file.

```typescript
interface PathContext {
  projectId: string;
  fileType: FileType; // As defined above
  sessionId?: string;
  iteration?: number;
  stageSlug?: string;
  modelSlug?: string; // Sanitized model name/identifier
  originalFileName: string; // The original name of the file, used for display and part of the final path
}
```

### `UploadContext`

An object containing all information needed by `uploadAndRegisterFile` to store a file and its metadata.

```typescript
interface UploadContext {
  pathContext: PathContext;
  fileContent: Buffer | ArrayBuffer | string; // Main file content
  mimeType: string;
  sizeBytes: number;
  userId: string | null; // ID of the user performing the action, or null for system actions
  description?: string;   // Optional description for 'dialectic_project_resources'

  // Specific metadata for AI contributions, used when fileType maps to 'dialectic_contributions'
  contributionMetadata?: {
    rawJsonResponseContent?: Buffer | ArrayBuffer | string; // Optional: Raw JSON response from AI
    modelIdUsed: string;       // FK to ai_providers.id or ai_model_catalogs.id
    modelNameDisplay: string;  // User-friendly model name
    iterationNumber: number;
    tokensUsedInput?: number | null;
    tokensUsedOutput?: number | null;
    processingTimeMs?: number | null;
    seedPromptStoragePath?: string | null; // Storage path of the seed prompt used
    promptTemplateIdUsed?: string | null;
    citations?: any | null; // JSONB, e.g., [{text: "Source A", url: "link_to_source_a"}]
    contributionType?: string | null; // e.g., 'main_content', 'critique', 'prd_document'
    errorDetails?: string | null;     // Details if the AI model itself reported an error
    targetContributionId?: string | null; // For linking critiques or feedback to a specific contribution
    editVersion?: number;
    isLatestEdit?: boolean;
    originalModelContributionId?: string | null;
  };
}
```

## Public Methods

### `constructor(supabaseClient: SupabaseClient<Database>)`

Initializes a new instance of the `FileManagerService`.

*   **Parameters**:
    *   `supabaseClient`: An initialized Supabase client instance.
*   **Throws**:
    *   Error if the `SB_CONTENT_STORAGE_BUCKET` environment variable is not set.

### `async uploadAndRegisterFile(context: UploadContext): Promise<FileManagerResponse>`

Uploads a file to Supabase Storage and creates a corresponding metadata record in either `dialectic_project_resources` or `dialectic_contributions` table based on `context.pathContext.fileType`. If `context.pathContext.fileType` is `'model_contribution_main'` and `context.contributionMetadata.rawJsonResponseContent` is provided, it will also attempt to upload the raw JSON response to a corresponding path.

*   **Parameters**:
    *   `context`: `UploadContext` - The full context for the file upload.
*   **Returns**: `Promise<FileManagerResponse>`
    *   `FileManagerResponse`: An object `{ record: YourTableRecord | null, error: { message: string, details?: string } | null }`.
        *   `record`: The newly created database record from `dialectic_project_resources` or `dialectic_contributions`.
        *   `error`: An error object if the operation failed at any stage (storage upload, database insert).

### `async getFileSignedUrl(fileId: string, table: 'dialectic_project_resources' | 'dialectic_contributions'): Promise<{ signedUrl: string | null; error: Error | null }>`

Retrieves a temporary, short-lived signed URL for a file stored in Supabase Storage, allowing secure, direct client-side access (e.g., for downloads or viewing).

*   **Parameters**:
    *   `fileId`: `string` - The UUID of the file record in the database.
    *   `table`: `'dialectic_project_resources' | 'dialectic_contributions'` - The table where the file's metadata is stored.
*   **Returns**: `Promise<{ signedUrl: string | null; error: Error | null }>`
    *   `signedUrl`: The temporary URL if successful.
    *   `error`: An error object if the file record is not found or URL generation fails.

## Usage Examples

It's crucial that other backend services (Edge Functions) use `FileManagerService` for any operation that involves writing files related to the Dialectic feature.

### 1. Project Creation (`createProject.ts`)

When a user creates a new project and optionally uploads an initial prompt file:

```typescript
// In supabase/functions/dialectic-service/createProject.ts

// ... (setup, payload parsing)
if (promptFile) {
  const fileManager = new FileManagerService(dbAdminClient);
  const fileBuffer = await promptFile.arrayBuffer();

  const uploadResult = await fileManager.uploadAndRegisterFile({
    pathContext: {
      projectId: newProjectData.id,
      fileType: 'initial_user_prompt',
      originalFileName: promptFile.name,
    },
    fileContent: Buffer.from(fileBuffer),
    mimeType: promptFile.type,
    sizeBytes: promptFile.size,
    userId: user.id,
    description: 'Initial project prompt file',
  });

  if (uploadResult.error || !uploadResult.record) {
    // Handle error, potentially roll back project creation
    console.error("Error uploading initial prompt file:", uploadResult.error);
    // ...
  } else {
    // Link uploadResult.record.id to dialectic_projects.initial_prompt_resource_id
  }
}
// ...
```

### 2. Session Start (`startSession.ts`)

When a new Dialectic session is initiated, a user prompt specific to the session and system settings might be saved:

```typescript
// In supabase/functions/dialectic-service/startSession.ts

// ... (setup, create session record in DB)
const fileManager = new FileManagerService(dbClient); // Assuming dbClient is SupabaseClient

// Example: Save the user's prompt for this specific session
const userSessionPromptContent = "Detailed prompt for this session...";
const sessionPromptUpload = await fileManager.uploadAndRegisterFile({
  pathContext: {
    projectId: newSession.project_id,
    sessionId: newSession.id,
    iteration: 1, // Or current iteration
    fileType: 'user_prompt', // Or a more specific type like 'session_input_prompt'
    originalFileName: 'session_user_prompt.md',
  },
  fileContent: userSessionPromptContent,
  mimeType: 'text/markdown',
  sizeBytes: new TextEncoder().encode(userSessionPromptContent).length,
  userId: user.id, // User initiating the session
  description: `User prompt for session ${newSession.id}`,
});
// Handle sessionPromptUpload.error

// Example: Save system settings for this session
const systemSettings = { modelsUsed: ['model_a', 'model_b'], temperature: 0.7 };
const systemSettingsContent = JSON.stringify(systemSettings, null, 2);
const settingsUpload = await fileManager.uploadAndRegisterFile({
  pathContext: {
    projectId: newSession.project_id,
    sessionId: newSession.id,
    iteration: 1,
    fileType: 'system_settings',
    originalFileName: 'system_settings.json',
  },
  fileContent: systemSettingsContent,
  mimeType: 'application/json',
  sizeBytes: new TextEncoder().encode(systemSettingsContent).length,
  userId: user.id, // Or null if system generated implicitly
  description: `System settings for session ${newSession.id}, iteration 1`,
});
// Handle settingsUpload.error
// ...
```

### 3. Saving AI Model Contributions (`generateContributions.ts`)

When an AI model generates content for a stage (e.g., Thesis, Synthesis):

```typescript
// In supabase/functions/dialectic-service/generateContributions.ts (simplified)

// ... (after receiving aiResponse from callUnifiedAIModel)
const fileManager = new FileManagerService(dbClient);

const contributionUpload = await fileManager.uploadAndRegisterFile({
  pathContext: {
    projectId: sessionDetails.project_id,
    sessionId: sessionDetails.id,
    iteration: currentIterationNumber,
    stageSlug: stage.slug,
    modelSlug: sanitizeForPath(providerDetails.api_identifier || providerDetails.name),
    originalFileName: `${sanitizeForPath(providerDetails.api_identifier || providerDetails.name)}_${stage.slug}.md`,
    fileType: 'model_contribution_main',
  },
  fileContent: aiResponse.content, // The main Markdown/text output
  mimeType: aiResponse.contentType || 'text/markdown',
  sizeBytes: new TextEncoder().encode(aiResponse.content).length,
  userId: null, // AI contributions are system-generated in this context
  contributionMetadata: {
    rawJsonResponseContent: JSON.stringify(aiResponse.rawProviderResponse || {}), // The raw JSON
    modelIdUsed: modelIdForCall, // Actual ID of the AI provider/model config
    modelNameDisplay: providerDetails.name,
    iterationNumber: currentIterationNumber,
    tokensUsedInput: aiResponse.inputTokens,
    tokensUsedOutput: aiResponse.outputTokens,
    processingTimeMs: aiResponse.processingTimeMs,
    seedPromptStoragePath: seedPromptResource?.storage_path, // Path of the seed prompt file used
    // ... other metadata like citations, contributionType, etc.
  }
});

if (contributionUpload.error || !contributionUpload.record) {
  // Handle failed contribution saving
} else {
  // `contributionUpload.record` is the new dialectic_contributions row
  // Note: The raw JSON is uploaded by FileManagerService itself if rawJsonResponseContent is provided.
  // The path to the raw JSON is stored in `contributionUpload.record.raw_response_storage_path`.
}
// ...
```

### 4. Cloning a Project (Conceptual) (`cloneProject.ts`)

When cloning a project, `FileManagerService` would be used to duplicate each file from the source project into the new project's structure, creating new database records for each.

```typescript
// In supabase/functions/dialectic-service/cloneProject.ts (conceptual)

// ... (create new project record for `newProjectId`)
const fileManager = new FileManagerService(dbClient);

// 1. Fetch all `dialectic_project_resources` for `sourceProjectId`
for (const resource of sourceProjectResources) {
  // 2. Download/read content of `resource.storage_path`
  const { data: fileBlob, error: downloadError } = await dbClient.storage
    .from(resource.storage_bucket)
    .download(resource.storage_path);
  
  if (downloadError || !fileBlob) continue; // Skip if cannot download
  const fileContent = await fileBlob.arrayBuffer();

  // 3. Upload and register for the new project
  await fileManager.uploadAndRegisterFile({
    pathContext: {
      projectId: newProjectId, // New project ID
      fileType: resource.file_type, // Assuming file_type is stored or can be derived
      originalFileName: resource.file_name,
      // NOTE: `fileType` might need adjustment if it implies unique roles like 'initial_user_prompt'
      // It might be better to classify cloned files as 'general_resource' or similar in the new project.
    },
    fileContent: Buffer.from(fileContent),
    mimeType: resource.mime_type,
    sizeBytes: resource.size_bytes,
    userId: newProjectOwnerId,
    description: resource.resource_description, // Copy description
  });
}

// 4. Repeat for `dialectic_contributions` across all sessions of the source project,
//    adjusting `sessionId`, `iteration`, etc., for the new project structure.
// ...
```

## Important Considerations

*   **Central Authority**: Treat `FileManagerService` as the sole authority for creating file records and determining storage paths. Directly manipulating Supabase Storage or the file metadata tables (`dialectic_project_resources`, `dialectic_contributions`) outside of this service will lead to inconsistencies and bugs.
*   **Environment Variables**: The service relies on `SB_CONTENT_STORAGE_BUCKET` being correctly set in your Supabase project's environment variables.
*   **Error Handling**: Always check the `error` field in the response from `uploadAndRegisterFile`. Implement appropriate rollback or compensation logic in the calling service if an error occurs (e.g., deleting a newly created project record if its initial prompt file fails to upload).
*   **Database Schema**: The `FileManagerService` assumes the structure of `dialectic_project_resources` and `dialectic_contributions` tables matches the fields it attempts to populate. Ensure your database migrations align with these expectations (see `types_db.ts`).

By adhering to the `FileManagerService`, developers can ensure a robust, maintainable, and consistent file management system for the Dialectic feature. 